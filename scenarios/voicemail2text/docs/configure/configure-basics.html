<!DOCTYPE html>

<html>

<head>

  <link rel="stylesheet" href="/docs/styles.css">

</head>


<body>

<h1>Configuration basics</h1>

<p>Administrators and integrators can configure V2TIC deployments following this process: 
    <ol>
        <li>Gather the specifications for your API.</li>
        <li>Create a profile script and templates.</li>
        <li>Create configuration and deployment files.</li>
        <li><a href="/docs/build-deploy/build-summary.html">Build and deploy V2TIC</a>.</li>
    </ol>
</p>

<h2>Gather specifications</h2>

<p>Before creating profiles and configurations, you need to know what the transcription request and response look like:</p>

<ul>
    <li>What are the headers and fields of the request? Which ones are mandatory? Which ones are custom headers? Languages?</li>
    <li>Does the response have a standard response? What is the maximum length of the transcription? Are any mandatory custom headers required to be included in the response?</li>
</ul>

<p>For example, this could be what an incoming request from a voicemail server looks like:</p>

<code>
    To: &lt;carrier&gt;-cc-voicemail@iot.slough.nuancevm.com 
        From: voice2textreply@example.com 
        Subject: New Voice Message
        Date: Fri, 31 Jan 2014 11:47:30 GMT
        Message-Id: 12345-abcde-67890
        X-Caller: 15551234567
        X-Caller-Name: John Smith
        X-Called: 15557654321
        X-Called-Name: Joe Bloggs
        X-Language: en-US
        Content-Type: audio/wav
        Content-Transfer-Encoding: base64
        
        UklGRqxhAABXQVZFZm10IBAAAAAHAAEAQB8AAEAfAAABAAgAZGF0YYBhAAD9
        &lt;snip&gt;
        yIS9kQ8qsgg9gAhkmAwN0ApI4YvqmBDd1Yvr+IzwGIdyOId0Wid2eId4mId6               
</code>

<p>You decide that the <tt>From</tt>, <tt>To</tt>, and <tt>Message-Id</tt> headers are mandatory.</p>

<p>For the response, you decide the <tt>Message-Id</tt> header is mandatory to include, and the maximum transcription length is 3000 characters (approximately 600 words).</p>

<h2>Create a profile and templates</h2>

<p>The next step is to build the profile and templates based on the requirements you've gathered.</p>

<p>The templates are Jinja templates. To learn more about working with Jinja templates, go to <a href="https://jinja.palletsprojects.com/en/3.1.x/templates/">the Jinja documentation</a>. In V2TIC, these templates use the <tt>.j2</tt> extension. You must have at least <tt>request.j2</tt> and <tt>response.j2</tt> templates, which handle converting requests and responses, but you could have more depending on your needs.</p>

<p>Each deployment's profile and templates exist in a folder inside <tt>etc/profiles</tt>, with the templates in their own folder, like the samples included with the V2TIC project.</p>

<h3>Request template</h3>

<p>The request template defines what to keep from the original incoming request, along with additional metadata and configurations.</p>

<p>Here is an example <tt>request.j2</tt> template for an SMTP deployment:</p>

<code>
    {
        "profile": "sample-smtp",
        "scrid": "{{request.scrid}}",
        "pass_through_data": {
          "from": "{{request.headers.From}}",
          "to": "{{request.headers.To}}",
          "message_id": "{{request.headers['Message-Id']}}"
            },
        "metadata": {
          "deposit_time": "{{request.deposit_time}}",
          "language": "{{request.headers['X-Language']}}",
          "language_configuration": {
            "en-US": {
                    "min_confidence_percentage": "60",
                    "max_audio_length_msecs": "240000"
                },
                "es-US": {
                    "min_confidence_percentage": "55",
                    "max_audio_length_msecs": "240000"
                }
                    },
                    "max_conversion_length": "{{request.max_conversion_length}}"
            },
            "acs_client": {
                    "lid_enabled": "True",
        "lid_mode": "AtStartHighAccuracy",
        "profanity_option": "Masked",
        "log_transcriptions_enabled": "False"
      }
    }
</code>

<p>These are the key parts of the template:</p>

<ul>
    <li><tt>profile</tt>: Required. Refers to the profile used by this deployment.</li>
    <li><tt>scrid</tt>: The unique ID for this transcription, generated by V2TIC.</li>
    <li><tt>pass_through_data”</tt>: Contains key-pairs to be passed through into the response (in this example, the <tt>From</tt>, <tt>To</tt>, and <tt>Message-Id</tt> headers in the original request).</li>
    <li><tt>metadata</tt>: Contains key-pairs for metadata of the profile.</li>
    <li><tt>acs_client</tt>: Contains key-pair values for Azure AI configuration.</li>
</ul>

<h3>Response template</h3>

<p>The response template defines what content and in what order that content appears in the final response V2TIC sends out.</p>

<p>Here is an example <tt>response.j2</tt> template for an HTTPS deployment:</p>

<code>
    {
        "return_url": "{{request.headers['X-Return-Url']}}",
        "verify_ssl": "false",
        "headers": {
          "Content-Type": "application/xml; charset=utf-8",
           "X-Reference": "{{request.scrid}}",
           {% if request.status == "Success" -%}
              "X-RTF": "{{request.recognition_result.rtf}}",
              {% if(request.recognition_result.conversion_status == "Transcribed" and request.recognition_result.lid_enabled) -%}
              "X-Detected-Language-Constellation": "{{request.recognition_result.detected_languages}}",
              {%- endif %}
           {%- endif %}
          "Connection": "close"
        },
        "body": {
           "import": "response_body.j2",
           "encoding": "utf-8"
        }
     } 
     
</code>

<p>These are the key parts of the template:</p>

<ul>
    <li><tt>return_url</tt>: The URL where the final response is sent to. From the passthrough data.</li>
    <li><tt>headers</tt>: Contains key-pair headers for the response.</li>
    <li><tt>body</tt>: Defines the actual message in the response.</li>
    <li><tt>encoding</tt>: Defines the encoding format. For example, utf-8, iso-8859-1, ascii, and more.</li>
</ul>

<p>Here is an example <tt>response.j2</tt> template for an SMTP deployment:</p>

<code>
    {
        {# optionally put response_address or will default to configured smtp.response_host:smtp.reponse_port
        "response_address": "192.168.1.4:9025",
        #}
     
        {# if start_tls is not configured, will default to false #}
        "start_tls": "false",
     
        {# fetch required metadata from pass_through_data or from original request headers #}
        "mail_from": "{{request.headers.To}}",
        "rcpt_to": "{{request.headers.From}}",
     
        "headers": {
          "Content-Type": "text/plain; charset=utf-8",
          "Subject": "{{request.headers.Subject}}",
          "Message-Id": "{{request.headers['Message-Id']}}",
          "Connection": "close"
        },
        "body": {
           "import": "response_body.j2",
           "encoding": "utf-8"
        }
     }
</code>

<p>These are the key parts of the template:</p>

<ul>
    <li><tt>mail_from</tt>: An SMTP command.</li>
    <li><tt>rcpt_to</tt>: An SMTP command.</li>
    <li><tt>headers</tt>: Contains key-pair headers for the response.</li>
    <li><tt>body</tt>: Defines the actual message in the response.</li>
    <li><tt>encoding</tt>: Defines the encoding format. For example, utf-8, iso-8859-1, ascii, and more.</li>
</ul>

<p>These examples use an additional template, <tt>response-body.j2</tt>, which defines the format of what the ultimate end user of the transcription will see.</p>

<p>Here is an example <tt>response-body.j2</tt> template for an SMTP deployment:</p>

<code>
{{request.recognition_result.text}}

------------------------------------------
Transcribed using V2TIC

scrid: {{request.scrid}}
conversion_status: {{request.recognition_result.conversion_status}}
recognition_status: {{request.recognition_result.status}}
{% if request.recognition_result.conversion_status == "TRANSCRIBED" -%}
converted_text: {{request.recognition_result.text}}
{% else -%}
{{“This person called and left you a message. Please call voicemail – Nuance” }}
{%- endif %}
display_text: {{request.recognition_result.display_text}}
itn_text: {{request.recognition_result.itn_text}}
global_confidence_score: {{request.recognition_result.global_confidence_score}}
rtf: {{request.recognition_result.rtf}}
recognition_duration: {{request.recognition_result.duration}}
audio_duration_secs: {{request.recognition_result.final_audio_length_secs}}
audio_duration_mSecs: {{request.recognition_result.final_audio_length_msecs}}
audio_truncated: {{request.recognition_result.audio_truncated}}
requested_languages: {{request.recognition_result.requested_languages}}
{% if request.recognition_result.lid_enabled == "true" -%}
lid_enabled: true
detected_languages: {{request.recognition_result.detected_languages}}
{%- endif %}
</code>

<p><b>Note:</b> This example mentions <tt>itn_text</tt>, which is Inverse Text Normalization. Go to the <a href="https://learn.microsoft.com/en-us/azure/ai-services/speech-service/display-text-format?pivots=programming-language-python">Azure AI</a> documentation to learn more.</p>

<h3>Profile</h3>

<p><tt>profile.py</tt> defines a class for handling SMTP- or HTTPS-related operations. These include obtaining mandatory headers and how to handle responses based on the success or failure of transcription.</p>

<p>The profile imports fields, headers, and constants from <tt>v2ticlib</tt>. It also imports the global profile class from <tt>AbstractProfile</tt> in the <tt>Common</tt> folder.</p>

<p>Here is an example <tt>profile.py</tt> template for an SMTP deployment:</p>

<code>
    import typing
import v2ticlib.constants.fields as Fields
import v2ticlib.constants.headers as Headers
import v2ticlib.constants.constants as constants
from Common.abstract_profile import AbstractProfile

class SampleSmtpProfile(AbstractProfile):

    def get_mandatory_headers(cls):
        return [Headers.FROM, Headers.MESSAGE_ID, Headers.TO]

    def get_request_context(cls, context:dict[str, any], headers:typing.Mapping[str, str]) -> dict[str, any]:
        context[Fields.MAX_CONVERSION_LENGTH] = 3000
        return context

    def update_response_hook(cls, request: dict[str, any], response: dict[str, any]) -> dict[str, any]:
        recognition_result = request[Fields.RECOGNITION_RESULT]
        if recognition_result[Fields.STATUS] == constants.TRANSCRIPTION_SUCCESS and recognition_result[Fields.LID_ENABLED] == constants.TRUE:
            response[Fields.HEADERS][Headers.X_DETECTED_LANGUAGE_CONSTELLATION] = recognition_result[Fields.DETECTED_LANGUAGES]

        return response
</code>

<p>This profile also declares the maximum character length for the transcription from the Gather Requirements step: <code>context[Fields.MAX_CONVERSION_LENGTH] = 3000</code>. This profile class also has a unique name.</p>

<h2>Create configuration and deployment files</h2>

<p>After creating the profile and templates, you can create the <tt>configmap-file.yaml</tt> and <tt>deployment.yaml</tt> files. These files define and configure the V2TIC image you'll build for your deployment.</p>

<p>These files have fixed formats and must be in a folder under <tt>etc/deployments</tt>. When creating your own, use the samples provided in the project. Only change the values of the key-pairs. Go to <a href="/docs/reference/deploy-configurations-templates.html">Configuration fields</a> to learn about creating <tt>configmap-file.yaml</tt> files.</p>

<h2>What's next</h2>

<p>Once you've created your profile, template, configuration, and deployment files, you can <a href="/docs/build-deploy/build-summary.html">build and deploy</a> your V2TIC deployment.</p>

<p><a href="/docs/index.html">Return to table of contents</a></p>
</body></html>